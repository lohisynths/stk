<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.2.8.1 -->
<h1>RtAudio.h</h1><div class="fragment"><pre>00001 <font class="comment">/******************************************/</font>
00002 <font class="comment">/*</font>
00003 <font class="comment">  RtAudio - realtime sound I/O C++ class</font>
00004 <font class="comment">  by Gary P. Scavone, 2001-2002.</font>
00005 <font class="comment">*/</font>
00006 <font class="comment">/******************************************/</font>
00007 
00008 <font class="preprocessor">#if !defined(__RTAUDIO_H)</font>
00009 <font class="preprocessor"></font><font class="preprocessor">#define __RTAUDIO_H</font>
00010 <font class="preprocessor"></font>
00011 <font class="preprocessor">#include &lt;map&gt;</font>
00012 
00013 <font class="preprocessor">#if defined(__LINUX_ALSA__)</font>
00014 <font class="preprocessor"></font><font class="preprocessor">  #include &lt;alsa/asoundlib.h&gt;</font>
00015 <font class="preprocessor">  #include &lt;pthread.h&gt;</font>
00016 <font class="preprocessor">  #include &lt;unistd.h&gt;</font>
00017 
00018 <font class="preprocessor">  #define THREAD_TYPE</font>
00019 <font class="preprocessor"></font>  <font class="keyword">typedef</font> snd_pcm_t *AUDIO_HANDLE;
00020   <font class="keyword">typedef</font> <font class="keywordtype">int</font> DEVICE_ID;
00021   <font class="keyword">typedef</font> pthread_t THREAD_HANDLE;
00022   <font class="keyword">typedef</font> pthread_mutex_t MUTEX;
00023 
00024 <font class="preprocessor">#elif defined(__LINUX_OSS__)</font>
00025 <font class="preprocessor"></font><font class="preprocessor">  #include &lt;pthread.h&gt;</font>
00026 <font class="preprocessor">  #include &lt;unistd.h&gt;</font>
00027 
00028 <font class="preprocessor">  #define THREAD_TYPE</font>
00029 <font class="preprocessor"></font>  <font class="keyword">typedef</font> <font class="keywordtype">int</font> AUDIO_HANDLE;
00030   <font class="keyword">typedef</font> <font class="keywordtype">int</font> DEVICE_ID;
00031   <font class="keyword">typedef</font> pthread_t THREAD_HANDLE;
00032   <font class="keyword">typedef</font> pthread_mutex_t MUTEX;
00033 
00034 <font class="preprocessor">#elif defined(__WINDOWS_DS__)</font>
00035 <font class="preprocessor"></font><font class="preprocessor">  #include &lt;windows.h&gt;</font>
00036 <font class="preprocessor">  #include &lt;process.h&gt;</font>
00037 
00038   <font class="comment">// The following struct is used to hold the extra variables</font>
00039   <font class="comment">// specific to the DirectSound implementation.</font>
00040   <font class="keyword">typedef</font> <font class="keyword">struct </font>{
00041     <font class="keywordtype">void</font> * object;
00042     <font class="keywordtype">void</font> * buffer;
00043     UINT bufferPointer;
00044   } AUDIO_HANDLE;
00045 
00046 <font class="preprocessor">  #define THREAD_TYPE __stdcall</font>
00047 <font class="preprocessor"></font>  <font class="keyword">typedef</font> LPGUID DEVICE_ID;
00048   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> THREAD_HANDLE;
00049   <font class="keyword">typedef</font> CRITICAL_SECTION MUTEX;
00050 
00051 <font class="preprocessor">#elif defined(__IRIX_AL__)</font>
00052 <font class="preprocessor"></font><font class="preprocessor">  #include &lt;dmedia/audio.h&gt;</font>
00053 <font class="preprocessor">  #include &lt;pthread.h&gt;</font>
00054 <font class="preprocessor">  #include &lt;unistd.h&gt;</font>
00055 
00056 <font class="preprocessor">  #define THREAD_TYPE</font>
00057 <font class="preprocessor"></font>  <font class="keyword">typedef</font> ALport AUDIO_HANDLE;
00058   <font class="keyword">typedef</font> <font class="keywordtype">int</font> DEVICE_ID;
00059   <font class="keyword">typedef</font> pthread_t THREAD_HANDLE;
00060   <font class="keyword">typedef</font> pthread_mutex_t MUTEX;
00061 
00062 <font class="preprocessor">#endif</font>
00063 <font class="preprocessor"></font>
00064 
00065 <font class="comment">// *************************************************** //</font>
00066 <font class="comment">//</font>
00067 <font class="comment">// RtError class declaration.</font>
00068 <font class="comment">//</font>
00069 <font class="comment">// *************************************************** //</font>
00070 
00071 <font class="keyword">class </font>RtError
00072 {
00073 <font class="keyword">public</font>:
00074   <font class="keyword">enum</font> TYPE {
00075     WARNING,
00076     DEBUG_WARNING,
00077     UNSPECIFIED,
00078     NO_DEVICES_FOUND,
00079     INVALID_DEVICE,
00080     INVALID_STREAM,
00081     MEMORY_ERROR,
00082     INVALID_PARAMETER,
00083     DRIVER_ERROR,
00084     SYSTEM_ERROR,
00085     THREAD_ERROR
00086   };
00087 
00088 <font class="keyword">protected</font>:
00089   <font class="keywordtype">char</font> error_message[256];
00090   TYPE type;
00091 
00092 <font class="keyword">public</font>:
00094   RtError(<font class="keyword">const</font> <font class="keywordtype">char</font> *p, TYPE tipe = RtError::UNSPECIFIED);
00095 
00097   <font class="keyword">virtual</font> ~RtError(<font class="keywordtype">void</font>);
00098 
00100   <font class="keyword">virtual</font> <font class="keywordtype">void</font> printMessage(<font class="keywordtype">void</font>);
00101 
00103   <font class="keyword">virtual</font> <font class="keyword">const</font> TYPE&amp; getType(<font class="keywordtype">void</font>)<font class="keyword"> </font>{ <font class="keywordflow">return</font> type; }
00104 
00106   <font class="keyword">virtual</font> <font class="keyword">const</font> <font class="keywordtype">char</font> *getMessage(<font class="keywordtype">void</font>)<font class="keyword"> </font>{ <font class="keywordflow">return</font> error_message; }
00107 };
00108 
00109 
00110 <font class="comment">// *************************************************** //</font>
00111 <font class="comment">//</font>
00112 <font class="comment">// RtAudio class declaration.</font>
00113 <font class="comment">//</font>
00114 <font class="comment">// *************************************************** //</font>
00115 
00116 <font class="keyword">class </font>RtAudio
00117 {
00118 <font class="keyword">public</font>:
00119 
00120   <font class="comment">// Support for signed integers and floats.  Audio data fed to/from</font>
00121   <font class="comment">// the tickStream() routine is assumed to ALWAYS be in host</font>
00122   <font class="comment">// byte order.  The internal routines will automatically take care of</font>
00123   <font class="comment">// any necessary byte-swapping between the host format and the</font>
00124   <font class="comment">// soundcard.  Thus, endian-ness is not a concern in the following</font>
00125   <font class="comment">// format definitions.</font>
00126   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> RTAUDIO_FORMAT;
00127   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_SINT8;
00128   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_SINT16;
00129   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_SINT24; 
00130   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_SINT32;
00131   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_FLOAT32; 
00132   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_FLOAT64; 
00133 
00134   <font class="comment">//static const int MAX_SAMPLE_RATES = 14;</font>
00135   <font class="keyword">enum</font> { MAX_SAMPLE_RATES = 14 };
00136 
00137   <font class="keyword">typedef</font> int (*RTAUDIO_CALLBACK)(<font class="keywordtype">char</font> *buffer, <font class="keywordtype">int</font> bufferSize, <font class="keywordtype">void</font> *userData);
00138 
00139   <font class="keyword">typedef</font> <font class="keyword">struct </font>{
00140     <font class="keywordtype">char</font> name[128];
00141     DEVICE_ID id[2];  
00142     <font class="keywordtype">bool</font> probed;       
00143     <font class="keywordtype">int</font> maxOutputChannels;
00144     <font class="keywordtype">int</font> maxInputChannels;
00145     <font class="keywordtype">int</font> maxDuplexChannels;
00146     <font class="keywordtype">int</font> minOutputChannels;
00147     <font class="keywordtype">int</font> minInputChannels;
00148     <font class="keywordtype">int</font> minDuplexChannels;
00149     <font class="keywordtype">bool</font> hasDuplexSupport; 
00150     <font class="keywordtype">int</font> nSampleRates;      
00151     <font class="keywordtype">int</font> sampleRates[MAX_SAMPLE_RATES]; 
00152     RTAUDIO_FORMAT nativeFormats;     
00153   } RTAUDIO_DEVICE;
00154 
00156 
00163   RtAudio();
00164 
00166 
00177   RtAudio(<font class="keywordtype">int</font> *streamId,
00178           <font class="keywordtype">int</font> outputDevice, <font class="keywordtype">int</font> outputChannels,
00179           <font class="keywordtype">int</font> inputDevice, <font class="keywordtype">int</font> inputChannels,
00180           RTAUDIO_FORMAT format, <font class="keywordtype">int</font> sampleRate,
00181           <font class="keywordtype">int</font> *bufferSize, <font class="keywordtype">int</font> numberOfBuffers);
00182 
00184 
00188   ~RtAudio();
00189 
00191 
00218   <font class="keywordtype">int</font> openStream(<font class="keywordtype">int</font> outputDevice, <font class="keywordtype">int</font> outputChannels,
00219                  <font class="keywordtype">int</font> inputDevice, <font class="keywordtype">int</font> inputChannels,
00220                  RTAUDIO_FORMAT format, <font class="keywordtype">int</font> sampleRate,
00221                  <font class="keywordtype">int</font> *bufferSize, <font class="keywordtype">int</font> numberOfBuffers);
00222 
00224 
00243   <font class="keywordtype">void</font> setStreamCallback(<font class="keywordtype">int</font> streamId, RTAUDIO_CALLBACK callback, <font class="keywordtype">void</font> *userData);
00244 
00246 
00253   <font class="keywordtype">void</font> cancelStreamCallback(<font class="keywordtype">int</font> streamId);
00254 
00256   <font class="keywordtype">int</font> getDeviceCount(<font class="keywordtype">void</font>);
00257 
00259 
00269   <font class="keywordtype">void</font> getDeviceInfo(<font class="keywordtype">int</font> device, RTAUDIO_DEVICE *info);
00270 
00272 
00277   <font class="keywordtype">char</font> * <font class="keyword">const</font> getStreamBuffer(<font class="keywordtype">int</font> streamId);
00278 
00280 
00285   <font class="keywordtype">void</font> tickStream(<font class="keywordtype">int</font> streamId);
00286 
00288 
00292   <font class="keywordtype">void</font> closeStream(<font class="keywordtype">int</font> streamId);
00293 
00295 
00299   <font class="keywordtype">void</font> startStream(<font class="keywordtype">int</font> streamId);
00300 
00302 
00306   <font class="keywordtype">void</font> stopStream(<font class="keywordtype">int</font> streamId);
00307 
00309 
00313   <font class="keywordtype">void</font> abortStream(<font class="keywordtype">int</font> streamId);
00314 
00316 
00321   <font class="keywordtype">int</font> streamWillBlock(<font class="keywordtype">int</font> streamId);
00322 
00323 <font class="keyword">protected</font>:
00324 
00325 <font class="keyword">private</font>:
00326 
00327   <font class="keyword">static</font> <font class="keyword">const</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> SAMPLE_RATES[MAX_SAMPLE_RATES];
00328 
00329   <font class="keyword">enum</font> { FAILURE, SUCCESS };
00330 
00331   <font class="keyword">enum</font> STREAM_MODE {
00332     PLAYBACK,
00333     RECORD,
00334     DUPLEX,
00335     UNINITIALIZED = -75
00336   };
00337 
00338   <font class="keyword">enum</font> STREAM_STATE {
00339     STREAM_STOPPED,
00340     STREAM_RUNNING
00341   };
00342 
00343   <font class="keyword">typedef</font> <font class="keyword">struct </font>{
00344     <font class="keywordtype">int</font> device[2];          <font class="comment">// Playback and record, respectively.</font>
00345     STREAM_MODE mode;       <font class="comment">// PLAYBACK, RECORD, or DUPLEX.</font>
00346     AUDIO_HANDLE handle[2]; <font class="comment">// Playback and record handles, respectively.</font>
00347     STREAM_STATE state;     <font class="comment">// STOPPED or RUNNING</font>
00348     <font class="keywordtype">char</font> *userBuffer;
00349     <font class="keywordtype">char</font> *deviceBuffer;
00350     <font class="keywordtype">bool</font> doConvertBuffer[2]; <font class="comment">// Playback and record, respectively.</font>
00351     <font class="keywordtype">bool</font> deInterleave[2];    <font class="comment">// Playback and record, respectively.</font>
00352     <font class="keywordtype">bool</font> doByteSwap[2];      <font class="comment">// Playback and record, respectively.</font>
00353     <font class="keywordtype">int</font> sampleRate;
00354     <font class="keywordtype">int</font> bufferSize;
00355     <font class="keywordtype">int</font> nBuffers;
00356     <font class="keywordtype">int</font> nUserChannels[2];    <font class="comment">// Playback and record, respectively.</font>
00357     <font class="keywordtype">int</font> nDeviceChannels[2];  <font class="comment">// Playback and record channels, respectively.</font>
00358     RTAUDIO_FORMAT userFormat;
00359     RTAUDIO_FORMAT deviceFormat[2]; <font class="comment">// Playback and record, respectively.</font>
00360     <font class="keywordtype">bool</font> usingCallback;
00361     THREAD_HANDLE thread;
00362     MUTEX mutex;
00363     RTAUDIO_CALLBACK callback;
00364     <font class="keywordtype">void</font> *userData;
00365   } RTAUDIO_STREAM;
00366 
00367   <font class="keyword">typedef</font> <font class="keywordtype">signed</font> <font class="keywordtype">short</font> INT16;
00368   <font class="keyword">typedef</font> <font class="keywordtype">signed</font> <font class="keywordtype">int</font> INT32;
00369   <font class="keyword">typedef</font> <font class="keywordtype">float</font> FLOAT32;
00370   <font class="keyword">typedef</font> <font class="keywordtype">double</font> FLOAT64;
00371 
00372   <font class="keywordtype">char</font> message[256];
00373   <font class="keywordtype">int</font> nDevices;
00374   RTAUDIO_DEVICE *devices;
00375 
00376   std::map&lt;int, void *&gt; streams;
00377 
00379   <font class="keywordtype">void</font> error(RtError::TYPE type);
00380 
00385   <font class="keywordtype">void</font> initialize(<font class="keywordtype">void</font>);
00386 
00388   <font class="keywordtype">void</font> clearDeviceInfo(RTAUDIO_DEVICE *info);
00389 
00397   <font class="keywordtype">void</font> probeDeviceInfo(RTAUDIO_DEVICE *info);
00398 
00405   <font class="keywordtype">bool</font> probeDeviceOpen(<font class="keywordtype">int</font> device, RTAUDIO_STREAM *stream,
00406                        STREAM_MODE mode, <font class="keywordtype">int</font> channels, 
00407                        <font class="keywordtype">int</font> sampleRate, RTAUDIO_FORMAT format,
00408                        <font class="keywordtype">int</font> *bufferSize, <font class="keywordtype">int</font> numberOfBuffers);
00409 
00416   <font class="keywordtype">void</font> *verifyStream(<font class="keywordtype">int</font> streamId);
00417 
00422   <font class="keywordtype">void</font> convertStreamBuffer(RTAUDIO_STREAM *stream, STREAM_MODE mode);
00423 
00425   <font class="keywordtype">void</font> byteSwapBuffer(<font class="keywordtype">char</font> *buffer, <font class="keywordtype">int</font> samples, RTAUDIO_FORMAT format);
00426 
00428   <font class="keywordtype">int</font> formatBytes(RTAUDIO_FORMAT format);
00429 };
00430 
00431 <font class="comment">// Uncomment the following definition to have extra information spewed to stderr.</font>
00432 <font class="comment">//#define RTAUDIO_DEBUG</font>
00433 
00434 <font class="preprocessor">#endif</font>
</font></pre></div><HR>

<table>
  <tr><td><A HREF="http://www-ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995-2002 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>

</BODY>
</HTML>
