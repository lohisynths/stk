<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"> &nbsp; <img src="mcgill.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="links.html">Links</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.3.4 -->
<h1>RtAudio.h</h1><div class="fragment"><pre>00001 <span class="comment">/************************************************************************/</span>
00038 <span class="comment">/************************************************************************/</span>
00039 
00040 <span class="comment">// RtAudio: Version 3.0.2, pre-release for STK 4.2.0</span>
00041 
00042 <span class="preprocessor">#ifndef __RTAUDIO_H</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define __RTAUDIO_H</span>
00044 <span class="preprocessor"></span>
00045 <span class="preprocessor">#include "RtError.h"</span>
00046 <span class="preprocessor">#include &lt;string&gt;</span>
00047 <span class="preprocessor">#include &lt;vector&gt;</span>
00048 
00049 <span class="comment">// Operating system dependent thread functionality.</span>
00050 <span class="preprocessor">#if defined(__WINDOWS_DS__) || defined(__WINDOWS_ASIO__)</span>
00051 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;windows.h&gt;</span>
00052 <span class="preprocessor">  #include &lt;process.h&gt;</span>
00053 
00054   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ThreadHandle;
00055   <span class="keyword">typedef</span> CRITICAL_SECTION StreamMutex;
00056 
00057 <span class="preprocessor">#else // Various unix flavors with pthread support.</span>
00058 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;pthread.h&gt;</span>
00059 
00060   <span class="keyword">typedef</span> pthread_t ThreadHandle;
00061   <span class="keyword">typedef</span> pthread_mutex_t StreamMutex;
00062 
00063 <span class="preprocessor">#endif</span>
00064 <span class="preprocessor"></span>
00065 <span class="comment">// This global structure type is used to pass callback information</span>
00066 <span class="comment">// between the private RtAudio stream structure and global callback</span>
00067 <span class="comment">// handling functions.</span>
00068 <span class="keyword">struct </span>CallbackInfo {
00069   <span class="keywordtype">void</span> *object;    <span class="comment">// Used as a "this" pointer.</span>
00070   ThreadHandle thread;
00071   <span class="keywordtype">bool</span> usingCallback;
00072   <span class="keywordtype">void</span> *callback;
00073   <span class="keywordtype">void</span> *userData;
00074   <span class="keywordtype">void</span> *apiInfo;   <span class="comment">// void pointer for API specific callback information</span>
00075 
00076   <span class="comment">// Default constructor.</span>
00077   CallbackInfo()
00078     :object(0), usingCallback(false), callback(0),
00079      userData(0), apiInfo(0) {}
00080 };
00081 
00082 <span class="comment">// Support for signed integers and floats.  Audio data fed to/from</span>
00083 <span class="comment">// the tickStream() routine is assumed to ALWAYS be in host</span>
00084 <span class="comment">// byte order.  The internal routines will automatically take care of</span>
00085 <span class="comment">// any necessary byte-swapping between the host format and the</span>
00086 <span class="comment">// soundcard.  Thus, endian-ness is not a concern in the following</span>
00087 <span class="comment">// format definitions.</span>
00088 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> RtAudioFormat;
00089 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT8 = 0x1;    
00090 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT16 = 0x2;   
00091 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT24 = 0x4;   
00092 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT32 = 0x8;   
00093 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_FLOAT32 = 0x10; 
00094 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_FLOAT64 = 0x20; 
00096 <span class="keyword">typedef</span> int (*RtAudioCallback)(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> bufferSize, <span class="keywordtype">void</span> *userData);
00097 
<a name="l00099"></a><a class="code" href="structRtAudioDeviceInfo.html">00099</a> <span class="keyword">struct </span><a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a> {
<a name="l00100"></a><a class="code" href="structRtAudioDeviceInfo.html#o0">00100</a>   std::string <a class="code" href="structRtAudioDeviceInfo.html#o0">name</a>;      
<a name="l00101"></a><a class="code" href="structRtAudioDeviceInfo.html#o1">00101</a>   <span class="keywordtype">bool</span> <a class="code" href="structRtAudioDeviceInfo.html#o1">probed</a>;          
<a name="l00102"></a><a class="code" href="structRtAudioDeviceInfo.html#o2">00102</a>   <span class="keywordtype">int</span> <a class="code" href="structRtAudioDeviceInfo.html#o2">outputChannels</a>;   
<a name="l00103"></a><a class="code" href="structRtAudioDeviceInfo.html#o3">00103</a>   <span class="keywordtype">int</span> <a class="code" href="structRtAudioDeviceInfo.html#o3">inputChannels</a>;    
<a name="l00104"></a><a class="code" href="structRtAudioDeviceInfo.html#o4">00104</a>   <span class="keywordtype">int</span> <a class="code" href="structRtAudioDeviceInfo.html#o4">duplexChannels</a>;   
<a name="l00105"></a><a class="code" href="structRtAudioDeviceInfo.html#o5">00105</a>   <span class="keywordtype">bool</span> <a class="code" href="structRtAudioDeviceInfo.html#o5">isDefault</a>;       
<a name="l00106"></a><a class="code" href="structRtAudioDeviceInfo.html#o6">00106</a>   std::vector&lt;int&gt; <a class="code" href="structRtAudioDeviceInfo.html#o6">sampleRates</a>; 
<a name="l00107"></a><a class="code" href="structRtAudioDeviceInfo.html#o7">00107</a>   RtAudioFormat <a class="code" href="structRtAudioDeviceInfo.html#o7">nativeFormats</a>;  
00109   <span class="comment">// Default constructor.</span>
00110   <a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a>()
00111     :<a class="code" href="structRtAudioDeviceInfo.html#o1">probed</a>(false), <a class="code" href="structRtAudioDeviceInfo.html#o2">outputChannels</a>(0), <a class="code" href="structRtAudioDeviceInfo.html#o3">inputChannels</a>(0),
00112        <a class="code" href="structRtAudioDeviceInfo.html#o4">duplexChannels</a>(0), <a class="code" href="structRtAudioDeviceInfo.html#o5">isDefault</a>(false), <a class="code" href="structRtAudioDeviceInfo.html#o7">nativeFormats</a>(0) {}
00113 };
00114 
00115 <span class="comment">// **************************************************************** //</span>
00116 <span class="comment">//</span>
00117 <span class="comment">// RtApi class declaration.</span>
00118 <span class="comment">//</span>
00119 <span class="comment">// Note that RtApi is an abstract base class and cannot be</span>
00120 <span class="comment">// explicitly instantiated.  The class RtAudio will create an</span>
00121 <span class="comment">// instance of an RtApi subclass (RtApiOss, RtApiAlsa,</span>
00122 <span class="comment">// RtApiJack, RtApiCore, RtApiAl, RtApiDs, or RtApiAsio).</span>
00123 <span class="comment">//</span>
00124 <span class="comment">// **************************************************************** //</span>
00125 
00126 <span class="keyword">class </span>RtApi
00127 {
00128 <span class="keyword">public</span>:
00129 
00130   <span class="keyword">enum</span> StreamState {
00131     STREAM_STOPPED,
00132     STREAM_RUNNING
00133   };
00134 
00135   RtApi();
00136   <span class="keyword">virtual</span> ~RtApi();
00137   <span class="keywordtype">void</span> openStream( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00138                    <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00139                    RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00140                    <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00141   <span class="keywordtype">void</span> openStream( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00142                    <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00143                    RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00144                    <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> *numberOfBuffers );
00145   <span class="keyword">virtual</span> <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData ) = 0;
00146   <span class="keyword">virtual</span> <span class="keywordtype">void</span> cancelStreamCallback() = 0;
00147   <span class="keywordtype">int</span> getDeviceCount(<span class="keywordtype">void</span>);
00148   <a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a> getDeviceInfo( <span class="keywordtype">int</span> device );
00149   <span class="keywordtype">char</span> * <span class="keyword">const</span> getStreamBuffer();
00150   RtApi::StreamState getStreamState() <span class="keyword">const</span>;
00151   <span class="keyword">virtual</span> <span class="keywordtype">void</span> tickStream() = 0;
00152   <span class="keyword">virtual</span> <span class="keywordtype">void</span> closeStream();
00153   <span class="keyword">virtual</span> <span class="keywordtype">void</span> startStream() = 0;
00154   <span class="keyword">virtual</span> <span class="keywordtype">void</span> stopStream() = 0;
00155   <span class="keyword">virtual</span> <span class="keywordtype">void</span> abortStream() = 0;
00156 
00157 <span class="keyword">protected</span>:
00158 
00159   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAX_SAMPLE_RATES;
00160   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> SAMPLE_RATES[];
00161 
00162   <span class="keyword">enum</span> { FAILURE, SUCCESS };
00163 
00164   <span class="keyword">enum</span> StreamMode {
00165     OUTPUT,
00166     INPUT,
00167     DUPLEX,
00168     UNINITIALIZED = -75
00169   };
00170 
00171   <span class="comment">// A protected structure used for buffer conversion.</span>
00172   <span class="keyword">struct </span>ConvertInfo {
00173     <span class="keywordtype">int</span> channels;
00174     <span class="keywordtype">int</span> inJump, outJump;
00175     RtAudioFormat inFormat, outFormat;
00176     std::vector&lt;int&gt; inOffset;
00177     std::vector&lt;int&gt; outOffset;
00178   };
00179 
00180   <span class="comment">// A protected structure for audio streams.</span>
00181   <span class="keyword">struct </span>RtApiStream {
00182     <span class="keywordtype">int</span> device[2];          <span class="comment">// Playback and record, respectively.</span>
00183     <span class="keywordtype">void</span> *apiHandle;        <span class="comment">// void pointer for API specific stream handle information</span>
00184     StreamMode mode;         <span class="comment">// OUTPUT, INPUT, or DUPLEX.</span>
00185     StreamState state;       <span class="comment">// STOPPED or RUNNING</span>
00186     <span class="keywordtype">char</span> *userBuffer;
00187     <span class="keywordtype">char</span> *deviceBuffer;
00188     <span class="keywordtype">bool</span> doConvertBuffer[2]; <span class="comment">// Playback and record, respectively.</span>
00189     <span class="keywordtype">bool</span> deInterleave[2];    <span class="comment">// Playback and record, respectively.</span>
00190     <span class="keywordtype">bool</span> doByteSwap[2];      <span class="comment">// Playback and record, respectively.</span>
00191     <span class="keywordtype">int</span> sampleRate;
00192     <span class="keywordtype">int</span> bufferSize;
00193     <span class="keywordtype">int</span> nBuffers;
00194     <span class="keywordtype">int</span> nUserChannels[2];    <span class="comment">// Playback and record, respectively.</span>
00195     <span class="keywordtype">int</span> nDeviceChannels[2];  <span class="comment">// Playback and record channels, respectively.</span>
00196     RtAudioFormat userFormat;
00197     RtAudioFormat deviceFormat[2]; <span class="comment">// Playback and record, respectively.</span>
00198     StreamMutex mutex;
00199     CallbackInfo callbackInfo;
00200     ConvertInfo convertInfo[2];
00201 
00202     RtApiStream()
00203       :apiHandle(0), userBuffer(0), deviceBuffer(0) {}
00204   };
00205 
00206   <span class="comment">// A protected device structure for audio devices.</span>
00207   <span class="keyword">struct </span>RtApiDevice {
00208     std::string name;      
00209     <span class="keywordtype">bool</span> probed;           
00210     <span class="keywordtype">void</span> *apiDeviceId;     <span class="comment">// void pointer for API specific device information</span>
00211     <span class="keywordtype">int</span> maxOutputChannels; 
00212     <span class="keywordtype">int</span> maxInputChannels;  
00213     <span class="keywordtype">int</span> maxDuplexChannels; 
00214     <span class="keywordtype">int</span> minOutputChannels; 
00215     <span class="keywordtype">int</span> minInputChannels;  
00216     <span class="keywordtype">int</span> minDuplexChannels; 
00217     <span class="keywordtype">bool</span> hasDuplexSupport; 
00218     <span class="keywordtype">bool</span> isDefault;        
00219     std::vector&lt;int&gt; sampleRates; 
00220     RtAudioFormat nativeFormats;  
00222     <span class="comment">// Default constructor.</span>
00223     RtApiDevice()
00224       :probed(false), apiDeviceId(0), maxOutputChannels(0), maxInputChannels(0),
00225        maxDuplexChannels(0), minOutputChannels(0), minInputChannels(0),
00226        minDuplexChannels(0), isDefault(false), nativeFormats(0) {}
00227   };
00228 
00229   <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">short</span> Int16;
00230   <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">int</span> Int32;
00231   <span class="keyword">typedef</span> <span class="keywordtype">float</span> Float32;
00232   <span class="keyword">typedef</span> <span class="keywordtype">double</span> Float64;
00233 
00234   <span class="keywordtype">char</span> message_[1024];
00235   <span class="keywordtype">int</span> nDevices_;
00236   std::vector&lt;RtApiDevice&gt; devices_;
00237   RtApiStream stream_;
00238 
00243   <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>) = 0;
00244 
00253   <span class="keyword">virtual</span> <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00254 
00263   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00264                                 <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00265                                 <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00266 
00271   <span class="keyword">virtual</span> <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00272 
00277   <span class="keyword">virtual</span> <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00278 
00280   <span class="keywordtype">void</span> clearDeviceInfo( RtApiDevice *info );
00281 
00283   <span class="keywordtype">void</span> clearStreamInfo();
00284 
00286   <span class="keywordtype">void</span> error( RtError::Type type );
00287 
00292   <span class="keywordtype">void</span> verifyStream();
00293 
00298   <span class="keywordtype">void</span> convertBuffer( <span class="keywordtype">char</span> *outBuffer, <span class="keywordtype">char</span> *inBuffer, ConvertInfo &amp;info );
00299 
00301   <span class="keywordtype">void</span> byteSwapBuffer( <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> samples, RtAudioFormat format );
00302 
00304   <span class="keywordtype">int</span> formatBytes( RtAudioFormat format );
00305 };
00306 
00307 
00308 <span class="comment">// **************************************************************** //</span>
00309 <span class="comment">//</span>
00310 <span class="comment">// RtAudio class declaration.</span>
00311 <span class="comment">//</span>
00312 <span class="comment">// RtAudio is a "controller" used to select an available audio i/o</span>
00313 <span class="comment">// interface.  It presents a common API for the user to call but all</span>
00314 <span class="comment">// functionality is implemented by the class RtAudioApi and its</span>
00315 <span class="comment">// subclasses.  RtAudio creates an instance of an RtAudioApi subclass</span>
00316 <span class="comment">// based on the user's API choice.  If no choice is made, RtAudio</span>
00317 <span class="comment">// attempts to make a "logical" API selection.</span>
00318 <span class="comment">//</span>
00319 <span class="comment">// **************************************************************** //</span>
00320 
<a name="l00321"></a><a class="code" href="classRtAudio.html">00321</a> <span class="keyword">class </span><a class="code" href="classRtAudio.html">RtAudio</a>
00322 {
00323 <span class="keyword">public</span>:
00324 
<a name="l00326"></a><a class="code" href="classRtAudio.html#w8">00326</a>   <span class="keyword">enum</span> <a class="code" href="classRtAudio.html#w8">RtAudioApi</a> {
00327     <a class="code" href="classRtAudio.html#w8w0">UNSPECIFIED</a>,    
00328     <a class="code" href="classRtAudio.html#w8w1">LINUX_ALSA</a>,     
00329     <a class="code" href="classRtAudio.html#w8w2">LINUX_OSS</a>,      
00330     <a class="code" href="classRtAudio.html#w8w3">LINUX_JACK</a>,     
00331     <a class="code" href="classRtAudio.html#w8w4">MACOSX_CORE</a>,    
00332     <a class="code" href="classRtAudio.html#w8w5">IRIX_AL</a>,        
00333     <a class="code" href="classRtAudio.html#w8w6">WINDOWS_ASIO</a>,   
00334     <a class="code" href="classRtAudio.html#w8w7">WINDOWS_DS</a>      
00335   };
00336 
00338 
00348   <a class="code" href="classRtAudio.html#a0">RtAudio</a>( RtAudioApi api=UNSPECIFIED );
00349 
00351 
00362   <a class="code" href="classRtAudio.html#a0">RtAudio</a>( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00363            <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00364            RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00365            <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers, RtAudioApi api=UNSPECIFIED );
00366 
00368 
00376   <a class="code" href="classRtAudio.html#a0">RtAudio</a>( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00377            <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00378            RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00379            <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> *numberOfBuffers, RtAudioApi api=UNSPECIFIED );
00380 
00382 
00386   <a class="code" href="classRtAudio.html#a3">~RtAudio</a>();
00387 
00389 
00415   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a4">openStream</a>( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00416                    <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00417                    RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00418                    <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00419 
00421 
00429   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a4">openStream</a>( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00430                    <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00431                    RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00432                    <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> *numberOfBuffers );
00433 
00435 
<a name="l00454"></a><a class="code" href="classRtAudio.html#a6">00454</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a6">setStreamCallback</a>(RtAudioCallback callback, <span class="keywordtype">void</span> *userData) { rtapi_-&gt;setStreamCallback( callback, userData ); };
00455 
00457 
<a name="l00464"></a><a class="code" href="classRtAudio.html#a7">00464</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a7">cancelStreamCallback</a>() { rtapi_-&gt;cancelStreamCallback(); };
00465 
<a name="l00467"></a><a class="code" href="classRtAudio.html#a8">00467</a>   <span class="keywordtype">int</span> <a class="code" href="classRtAudio.html#a8">getDeviceCount</a>(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> rtapi_-&gt;getDeviceCount(); };
00468 
00470 
<a name="l00478"></a><a class="code" href="classRtAudio.html#a9">00478</a>   <a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a> <a class="code" href="classRtAudio.html#a9">getDeviceInfo</a>(<span class="keywordtype">int</span> device) { <span class="keywordflow">return</span> rtapi_-&gt;getDeviceInfo( device ); };
00479 
00481 
<a name="l00486"></a><a class="code" href="classRtAudio.html#a10">00486</a>   <span class="keywordtype">char</span> * <span class="keyword">const</span> <a class="code" href="classRtAudio.html#a10">getStreamBuffer</a>() { <span class="keywordflow">return</span> rtapi_-&gt;getStreamBuffer(); };
00487 
00489 
<a name="l00494"></a><a class="code" href="classRtAudio.html#a11">00494</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a11">tickStream</a>() { rtapi_-&gt;tickStream(); };
00495 
00497 
<a name="l00501"></a><a class="code" href="classRtAudio.html#a12">00501</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a12">closeStream</a>()  { rtapi_-&gt;closeStream(); };
00502 
00504 
<a name="l00508"></a><a class="code" href="classRtAudio.html#a13">00508</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a13">startStream</a>() { rtapi_-&gt;startStream(); };
00509 
00511 
<a name="l00515"></a><a class="code" href="classRtAudio.html#a14">00515</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a14">stopStream</a>() { rtapi_-&gt;stopStream(); };
00516 
00518 
<a name="l00522"></a><a class="code" href="classRtAudio.html#a15">00522</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a15">abortStream</a>() { rtapi_-&gt;abortStream(); };
00523 
00524 
00525  <span class="keyword">protected</span>:
00526 
00527   <span class="keywordtype">void</span> initialize( RtAudioApi api );
00528 
00529   RtApi *rtapi_;
00530 };
00531 
00532 
00533 <span class="comment">// RtApi Subclass prototypes.</span>
00534 
00535 <span class="preprocessor">#if defined(__LINUX_ALSA__)</span>
00536 <span class="preprocessor"></span>
00537 <span class="keyword">class </span>RtApiAlsa: <span class="keyword">public</span> RtApi
00538 {
00539 <span class="keyword">public</span>:
00540 
00541   RtApiAlsa();
00542   ~RtApiAlsa();
00543   <span class="keywordtype">void</span> tickStream();
00544   <span class="keywordtype">void</span> closeStream();
00545   <span class="keywordtype">void</span> startStream();
00546   <span class="keywordtype">void</span> stopStream();
00547   <span class="keywordtype">void</span> abortStream();
00548   <span class="keywordtype">int</span> streamWillBlock();
00549   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00550   <span class="keywordtype">void</span> cancelStreamCallback();
00551 
00552   <span class="keyword">private</span>:
00553 
00554   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00555   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00556   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00557                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00558                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00559 };
00560 
00561 <span class="preprocessor">#endif</span>
00562 <span class="preprocessor"></span>
00563 <span class="preprocessor">#if defined(__LINUX_JACK__)</span>
00564 <span class="preprocessor"></span>
00565 <span class="keyword">class </span>RtApiJack: <span class="keyword">public</span> RtApi
00566 {
00567 <span class="keyword">public</span>:
00568 
00569   RtApiJack();
00570   ~RtApiJack();
00571   <span class="keywordtype">void</span> tickStream();
00572   <span class="keywordtype">void</span> closeStream();
00573   <span class="keywordtype">void</span> startStream();
00574   <span class="keywordtype">void</span> stopStream();
00575   <span class="keywordtype">void</span> abortStream();
00576   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00577   <span class="keywordtype">void</span> cancelStreamCallback();
00578   <span class="comment">// This function is intended for internal use only.  It must be</span>
00579   <span class="comment">// public because it is called by the internal callback handler,</span>
00580   <span class="comment">// which is not a member of RtAudio.  External use of this function</span>
00581   <span class="comment">// will most likely produce highly undesireable results!</span>
00582   <span class="keywordtype">void</span> callbackEvent( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nframes );
00583 
00584   <span class="keyword">private</span>:
00585 
00586   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00587   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00588   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00589                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00590                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00591 };
00592 
00593 <span class="preprocessor">#endif</span>
00594 <span class="preprocessor"></span>
00595 <span class="preprocessor">#if defined(__LINUX_OSS__)</span>
00596 <span class="preprocessor"></span>
00597 <span class="keyword">class </span>RtApiOss: <span class="keyword">public</span> RtApi
00598 {
00599 <span class="keyword">public</span>:
00600 
00601   RtApiOss();
00602   ~RtApiOss();
00603   <span class="keywordtype">void</span> tickStream();
00604   <span class="keywordtype">void</span> closeStream();
00605   <span class="keywordtype">void</span> startStream();
00606   <span class="keywordtype">void</span> stopStream();
00607   <span class="keywordtype">void</span> abortStream();
00608   <span class="keywordtype">int</span> streamWillBlock();
00609   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00610   <span class="keywordtype">void</span> cancelStreamCallback();
00611 
00612   <span class="keyword">private</span>:
00613 
00614   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00615   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00616   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00617                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00618                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00619 };
00620 
00621 <span class="preprocessor">#endif</span>
00622 <span class="preprocessor"></span>
00623 <span class="preprocessor">#if defined(__MACOSX_CORE__)</span>
00624 <span class="preprocessor"></span>
00625 <span class="preprocessor">#include &lt;CoreAudio/AudioHardware.h&gt;</span>
00626 
00627 <span class="keyword">class </span>RtApiCore: <span class="keyword">public</span> RtApi
00628 {
00629 <span class="keyword">public</span>:
00630 
00631   RtApiCore();
00632   ~RtApiCore();
00633   <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00634   <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00635   <span class="keywordtype">void</span> tickStream();
00636   <span class="keywordtype">void</span> closeStream();
00637   <span class="keywordtype">void</span> startStream();
00638   <span class="keywordtype">void</span> stopStream();
00639   <span class="keywordtype">void</span> abortStream();
00640   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00641   <span class="keywordtype">void</span> cancelStreamCallback();
00642 
00643   <span class="comment">// This function is intended for internal use only.  It must be</span>
00644   <span class="comment">// public because it is called by the internal callback handler,</span>
00645   <span class="comment">// which is not a member of RtAudio.  External use of this function</span>
00646   <span class="comment">// will most likely produce highly undesireable results!</span>
00647   <span class="keywordtype">void</span> callbackEvent( AudioDeviceID deviceId, <span class="keywordtype">void</span> *inData, <span class="keywordtype">void</span> *outData );
00648 
00649   <span class="keyword">private</span>:
00650 
00651   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00652   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00653   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00654                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00655                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00656 };
00657 
00658 <span class="preprocessor">#endif</span>
00659 <span class="preprocessor"></span>
00660 <span class="preprocessor">#if defined(__WINDOWS_DS__)</span>
00661 <span class="preprocessor"></span>
00662 <span class="keyword">class </span>RtApiDs: <span class="keyword">public</span> RtApi
00663 {
00664 <span class="keyword">public</span>:
00665 
00666   RtApiDs();
00667   ~RtApiDs();
00668   <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00669   <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00670   <span class="keywordtype">void</span> tickStream();
00671   <span class="keywordtype">void</span> closeStream();
00672   <span class="keywordtype">void</span> startStream();
00673   <span class="keywordtype">void</span> stopStream();
00674   <span class="keywordtype">void</span> abortStream();
00675   <span class="keywordtype">int</span> streamWillBlock();
00676   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00677   <span class="keywordtype">void</span> cancelStreamCallback();
00678 
00679   <span class="keyword">private</span>:
00680 
00681   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00682   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00683   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00684                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00685                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00686 };
00687 
00688 <span class="preprocessor">#endif</span>
00689 <span class="preprocessor"></span>
00690 <span class="preprocessor">#if defined(__WINDOWS_ASIO__)</span>
00691 <span class="preprocessor"></span>
00692 <span class="keyword">class </span>RtApiAsio: <span class="keyword">public</span> RtApi
00693 {
00694 <span class="keyword">public</span>:
00695 
00696   RtApiAsio();
00697   ~RtApiAsio();
00698   <span class="keywordtype">void</span> tickStream();
00699   <span class="keywordtype">void</span> closeStream();
00700   <span class="keywordtype">void</span> startStream();
00701   <span class="keywordtype">void</span> stopStream();
00702   <span class="keywordtype">void</span> abortStream();
00703   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00704   <span class="keywordtype">void</span> cancelStreamCallback();
00705 
00706   <span class="comment">// This function is intended for internal use only.  It must be</span>
00707   <span class="comment">// public because it is called by the internal callback handler,</span>
00708   <span class="comment">// which is not a member of RtAudio.  External use of this function</span>
00709   <span class="comment">// will most likely produce highly undesireable results!</span>
00710   <span class="keywordtype">void</span> callbackEvent( <span class="keywordtype">long</span> bufferIndex );
00711 
00712   <span class="keyword">private</span>:
00713 
00714   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00715   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00716   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00717                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00718                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00719 };
00720 
00721 <span class="preprocessor">#endif</span>
00722 <span class="preprocessor"></span>
00723 <span class="preprocessor">#if defined(__IRIX_AL__)</span>
00724 <span class="preprocessor"></span>
00725 <span class="keyword">class </span>RtApiAl: <span class="keyword">public</span> RtApi
00726 {
00727 <span class="keyword">public</span>:
00728 
00729   RtApiAl();
00730   ~RtApiAl();
00731   <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00732   <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00733   <span class="keywordtype">void</span> tickStream();
00734   <span class="keywordtype">void</span> closeStream();
00735   <span class="keywordtype">void</span> startStream();
00736   <span class="keywordtype">void</span> stopStream();
00737   <span class="keywordtype">void</span> abortStream();
00738   <span class="keywordtype">int</span> streamWillBlock();
00739   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00740   <span class="keywordtype">void</span> cancelStreamCallback();
00741 
00742   <span class="keyword">private</span>:
00743 
00744   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00745   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00746   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00747                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00748                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00749 };
00750 
00751 <span class="preprocessor">#endif</span>
00752 <span class="preprocessor"></span>
00753 <span class="comment">// Define the following flag to have extra information spewed to stderr.</span>
00754 <span class="comment">//#define __RTAUDIO_DEBUG__</span>
00755 
00756 <span class="preprocessor">#endif</span>
</pre></div><HR>

<table>
  <tr><td><A HREF="http://ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995-2004 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>

</BODY>
</HTML>
