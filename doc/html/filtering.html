<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"> &nbsp; <img src="mcgill.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="links.html">Links</a> &nbsp; <a class="qindex" href="faq.html">FAQ</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="filtering">Using Filters</a></h1>In this section, we demonstrate the use of a few of the STK filter classes. The <a class="el" href="classFilter.html">Filter</a> class provides functionality to implement a generalized digital filter of any type, similar to the <code>filter</code> function in Matlab. In this example, we create a <a class="el" href="classFilter.html">Filter</a> instance and initialize it with specific numerator and denominator coefficients. We then compute its impulse response for 20 samples.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "Filter.h"</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classStkFrames.html">StkFrames</a> output( 20, 1 );   <span class="comment">// initialize StkFrames to 20 frames and 1 channel (default: interleaved)</span>
  output[0] = 1.0;

  std::vector&lt;StkFloat&gt; numerator( 5, 0.1 ); <span class="comment">// create and initialize numerator coefficients</span>
  std::vector&lt;StkFloat&gt; denominator;         <span class="comment">// create empty denominator coefficients</span>
  denominator.push_back( 1.0 );              <span class="comment">// populate our denomintor values</span>
  denominator.push_back( 0.3 );
  denominator.push_back( -0.5 );

  <a class="code" href="classFilter.html">Filter</a> filter( numerator, denominator );

  filter.tick( output );
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;output.size(); i++ ) {
    std::cout &lt;&lt; <span class="stringliteral">"i = "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" : output = "</span> &lt;&lt; output[i] &lt;&lt; std::endl;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
The <a class="el" href="classFilter.html">Filter</a> class implements the standard difference equation <div class="fragment"><pre class="fragment"> a[0]*y[n] = b[0]*x[n] + ... + b[nb]*x[n-nb] - a[1]*y[n-1] - ... - a[na]*y[n-na],
</pre></div><p>
where "b" values are numerator coefficients and "a" values are denominator coefficients. Note that if the first denominator coefficient is not 1.0, the <a class="el" href="classFilter.html">Filter</a> class automatically normalizes all filter coefficients by that value. The coefficient values are passed to the <a class="el" href="classFilter.html">Filter</a> class via a C++ <a href="http://www.roguewave.com/support/docs/sourcepro/stdlibref/vector.html">vector</a>, a container object provided by the C++ Standard Library.<p>
Most STK classes use more specific types of digital filters, such as the <a class="el" href="classOneZero.html">OneZero</a>, <a class="el" href="classOnePole.html">OnePole</a>, <a class="el" href="classTwoPole.html">TwoPole</a>, or <a class="el" href="classBiQuad.html">BiQuad</a> varieties. These classes inherit from the <a class="el" href="classFilter.html">Filter</a> class and provide specific functionality particular to their use, as well as functions to independently control individual coefficient values.<h2><a class="anchor" name="reson">
Resonances:</a></h2>
The STK <a class="el" href="classBiQuad.html">BiQuad</a> and <a class="el" href="classTwoPole.html">TwoPole</a> classes provide functionality for creating resonance filters. The following example demonstrates how to create a resonance centered at 440 Hz that is used to filter the output of a <a class="el" href="classNoise.html">Noise</a> generator.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "BiQuad.h"</span>
<span class="preprocessor">#include "Noise.h"</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classStkFrames.html">StkFrames</a> output( 20, 1 );   <span class="comment">// initialize StkFrames to 20 frames and 1 channel (default: interleaved)</span>
  <a class="code" href="classNoise.html">Noise</a> noise;

  <a class="code" href="classBiQuad.html">BiQuad</a> biquad;
  biquad.<a class="code" href="classBiQuad.html#a9">setResonance</a>( 440.0, 0.98, <span class="keyword">true</span> ); <span class="comment">// automatically normalize for unity peak gain</span>

  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;output.size(); i++ ) {
    output[i] = biquad.<a class="code" href="classBiQuad.html#a15">tick</a>( noise.<a class="code" href="classGenerator.html#a3">tick</a>() );  <span class="comment">// single-sample computations</span>
    std::cout &lt;&lt; <span class="stringliteral">"i = "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" : output = "</span> &lt;&lt; output[i] &lt;&lt; std::endl;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
By passing a boolian value of <code>true</code> as the third argument to the <a class="el" href="classBiQuad.html#a9">BiQuad::setResonance()</a> function, the filter coefficients are automatically scaled to achieve unity gain at the resonance peak frequency. The previous code could be easily modified for "vector-based" calculations:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "BiQuad.h"</span>
<span class="preprocessor">#include "Noise.h"</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classStkFrames.html">StkFrames</a> output( 20, 1 );   <span class="comment">// initialize StkFrames to 20 frames and 1 channel (default: interleaved)</span>
  <a class="code" href="classNoise.html">Noise</a> noise;

  <a class="code" href="classBiQuad.html">BiQuad</a> biquad;
  biquad.<a class="code" href="classBiQuad.html#a9">setResonance</a>( 440.0, 0.98, <span class="keyword">true</span> ); <span class="comment">// automatically normalize for unity peak gain</span>

  biquad.<a class="code" href="classBiQuad.html#a15">tick</a>( noise.<a class="code" href="classGenerator.html#a3">tick</a>( output ) );      <span class="comment">// vector-based computations</span>
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;output.size(); i++ ) {
    std::cout &lt;&lt; <span class="stringliteral">"i = "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" : output = "</span> &lt;&lt; output[i] &lt;&lt; std::endl;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
[<a href="tutorial.html">Main tutorial page</a>] &nbsp; [<a href="realtime.html">Next tutorial</a>] <HR>

<table>
  <tr><td><A HREF="http://ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995-2007 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>

</BODY>
</HTML>
