<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"> &nbsp; <img src="mcgill.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="links.html">Links</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.3.4 -->
<h1><a class="anchor" name="crealtime">Realtime Audio (callback)</a></h1>The previous section described the use of the <a class="el" href="classRtWvOut.html">RtWvOut</a> class for realtime audio output. The <a class="el" href="classRtWvOut.html#a6">RtWvOut::tick()</a> function periodically pauses program execution in order to send a buffer of audio data to the computer's audio hardware (referred to as blocking functionality). These pauses will effectively limit a program's computations to the correct number of samples per second, which is defined by the sample rate of the hardware.<p>
An alternative scheme for audio input/output is to define a specific function in which audio computations are performed and to let the audio system call this function when more input/output data can be accepted by the hardware (referred to as a callback scheme). In this section, we show how the previous <code>rtsine.cpp</code> program can be modified to work in a callback scenario. There is no "single-sample" interface for this functionality. The callback function will be invoked automatically by the audio system controller (<a class="el" href="classRtAudio.html">RtAudio</a>) when new data is needed and it is necessary to compute a full audio buffer of samples at that time (see <a class="el" href="crealtime.html#callback">Blocking vs. Callbacks</a> for further information).<p>
<div class="fragment"><pre><span class="comment">// crtsine.cpp STK tutorial program</span>

<span class="preprocessor">#include "WaveLoop.h"</span>
<span class="preprocessor">#include "RtAudio.h"</span>

<span class="comment">// This tick() function handles sample computation only.  It will be</span>
<span class="comment">// called automatically when the system needs a new buffer of audio</span>
<span class="comment">// samples.</span>
<span class="keywordtype">int</span> tick(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> bufferSize, <span class="keywordtype">void</span> *dataPointer)
{
  <a class="code" href="classWaveLoop.html">WaveLoop</a> *sine = (<a class="code" href="classWaveLoop.html">WaveLoop</a> *) dataPointer;
  <span class="keyword">register</span> StkFloat *samples = (StkFloat *) buffer;

  <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;bufferSize; i++ )
    *samples++ = sine-&gt;<a class="code" href="classWvIn.html#a16">tick</a>();

  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> main()
{
  <span class="comment">// Set the global sample rate before creating class instances.</span>
  <a class="code" href="classStk.html#e1">Stk::setSampleRate</a>( 44100.0 );

  <a class="code" href="classWaveLoop.html">WaveLoop</a> *sine = 0;
  RtAudio *dac = 0;

  <span class="comment">// Figure out how many bytes in an StkFloat and setup the RtAudio object.</span>
  RtAudioFormat format = ( <span class="keyword">sizeof</span>(StkFloat) == 8 ) ? RTAUDIO_FLOAT64 : RTAUDIO_FLOAT32;
  <span class="keywordtype">int</span> bufferSize = RT_BUFFER_SIZE;
  <span class="keywordflow">try</span> {
    dac = <span class="keyword">new</span> RtAudio(0, 1, 0, 0, format, (<span class="keywordtype">int</span>)Stk::sampleRate(), &amp;bufferSize, 4);
  }
  <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html">RtError</a>&amp; error) {
    error.printMessage();
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="keywordflow">try</span> {
    <span class="comment">// Define and load the sine wave file</span>
    sine = <span class="keyword">new</span> <a class="code" href="classWaveLoop.html">WaveLoop</a>( <span class="stringliteral">"rawwaves/sinewave.raw"</span>, <span class="keyword">true</span> );
  }
  <span class="keywordflow">catch</span> (<a class="code" href="classStkError.html">StkError</a> &amp;) {
    <span class="keywordflow">goto</span> cleanup;
  }

  sine-&gt;<a class="code" href="classWaveLoop.html#a2">setFrequency</a>(440.0);

  <span class="keywordflow">try</span> {
    dac-&gt;<a class="code" href="classRtAudio.html#a6">setStreamCallback</a>(&amp;tick, (<span class="keywordtype">void</span> *)sine);
    dac-&gt;<a class="code" href="classRtAudio.html#a13">startStream</a>();
  }
  <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html">RtError</a> &amp;error) {
    error.printMessage();
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="comment">// Block waiting here.</span>
  <span class="keywordtype">char</span> keyhit;
  std::cout &lt;&lt; <span class="stringliteral">"\nPlaying ... press &lt;enter&gt; to quit.\n"</span>;
  std::cin.get(keyhit);

  <span class="comment">// Shut down the callback and output stream.</span>
  <span class="keywordflow">try</span> {
    dac-&gt;<a class="code" href="classRtAudio.html#a7">cancelStreamCallback</a>();
    dac-&gt;<a class="code" href="classRtAudio.html#a12">closeStream</a>();
  }
  <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html">RtError</a> &amp;error) {
    error.printMessage();
  }

 cleanup:

  <span class="keyword">delete</span> sine;
  <span class="keyword">delete</span> dac;

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
The sinusoidal oscillator is created as before. The instantiation of <a class="el" href="classRtAudio.html">RtAudio</a> requires quite a few more parameters, including output/input device and channel specifiers, the data format, and the desired buffer length (in frames). In this example, we request a single output channel using the default output device, zero channels of input, the <a class="el" href="classRtAudio.html">RtAudio</a> data format which corresponds to an <code>StkFloat</code>, and the RT_BUFFER_SIZE defined in <a class="el" href="Stk_8h.html">Stk.h</a>. The last argument is an API-dependent buffering parameter (see <a class="el" href="classRtAudio.html">RtAudio</a> for further information).<p>
After the digital-to-analog converter (dac) and oscillator are successfully created, it is necessary to provide the audio system controller with a pointer to our callback function. The <a class="el" href="classRtAudio.html#a6">RtAudio::setStreamCallback()</a> function takes a pointer to the callback function and an optional pointer to data that will be made available in the callback. In this example, we need to pass only the pointer to the oscillator. In more complex programs, it is typically necessary to put all shared data in a <code>struct</code> (see the next tutorial program for an example) or make use of global variables.<p>
Our callback routine is the <code>tick()</code> function. Function arguments include a pointer to the audio data buffer, the buffer size (in frames), and the data pointer passed to the <a class="el" href="classRtAudio.html#a6">RtAudio::setStreamCallback()</a> function (if it exists). It is necessary to cast these pointers to their corresponding data types before use. Our tick() routine simply "ticks" the oscillator for <code>bufferSize</code> counts and writes the result into the audio data buffer before returning.<p>
The <code>main()</code> function blocks at the std::cin.get() call until the user hits the "enter" key, after which the audio controller is shut down and program execution ends.<h2><a class="anchor" name="callback">
Blocking vs. Callbacks</a></h2>
Prior to version 4.2.0, all STK example projects and programs used blocking audio input/output functionality (typically with the <a class="el" href="classRtWvIn.html">RtWvIn</a>, <a class="el" href="classRtWvOut.html">RtWvOut</a>, or <a class="el" href="classRtDuplex.html">RtDuplex</a> classes). In many instances, a blocking scheme results in a clearer and more straight forward program structure. Within a graphical user interface (GUI) programming context, however, callback routines are often more natural.<p>
The <a class="el" href="classRtAudio.html">RtAudio</a> class provides both blocking and callback routines for all supported audio APIs. It should be noted that it is easy to embed blocking calls within a thread to create "callback-like" functionality. In fact, this is what <a class="el" href="classRtAudio.html">RtAudio</a> does for those audio APIs which are naturally based on blocking routines (Linux ALSA and OSS, SGI Irix, and Windows DirectSound). It is much more difficult to make an inherently callback-based system work like a blocking scheme. <a class="el" href="classRtAudio.html">RtAudio</a> attempts to do this with the Linux JACK, Macintosh OS-X CoreAudio, and Windows ASIO APIs, but the result is not fully robust (audio over/underruns are more likely to occur).<p>
In order to allow all STK programs to function with equal proficiency on all supported computer platforms, a decision was made to modify the example projects to use audio callback routines. The result is a more complicated code structure, which is unfortunate given that we generally strive to make STK code as clear as possible for educational purposes. This was especially an issue with the demo program because it is designed to function in both realtime and non-realtime contexts. The use of global variables has been avoided by defining data structures to hold all variables which must be accessible to the callback routine and other functions. Alternative schemes for making control updates could be designed depending on particular program needs and constraints.<p>
[<a href="instruments.html">Next tutorial</a>] &nbsp; [<a href="tutorial.html">Main tutorial page</a>] <HR>

<table>
  <tr><td><A HREF="http://ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995-2004 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>

</BODY>
</HTML>
