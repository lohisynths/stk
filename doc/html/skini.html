<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"> &nbsp; <img src="mcgill.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="links.html">Links</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.3.4 -->
<h1><a class="anchor" name="skini">Synthesis toolKit Instrument Network Interface (SKINI)</a></h1>This describes the latest (version 1.1) implementation of <a class="el" href="classSKINI.html">SKINI</a> for the Synthesis ToolKit in C++ (STK) by Perry R. Cook.<p>
<div class="fragment"><pre>        Too good to be <span class="keyword">true</span>?
    Have control and read it too?
          A <a class="code" href="classSKINI.html">SKINI</a> haiku.
</pre></div><p>
Profound thanks to Dan Trueman, Brad Garton, and Gary Scavone for input on this revision. Thanks also to MIDI, the NeXT MusicKit, ZIPI and all the creators and modifiers of these for good bases upon/from which to build and depart.<h2><a class="anchor" name="compatibility">
MIDI Compatibility</a></h2>
<a class="el" href="classSKINI.html">SKINI</a> was designed to be MIDI compatible wherever possible, and extend MIDI in incremental, then maybe profound ways.<p>
Differences from MIDI, and motivations, include:<p>
<ul>
<li>Text-based messages are used, with meaningful names wherever possible. This allows any language or system capable of formatted printing to generate <a class="el" href="classSKINI.html">SKINI</a>. Similarly, any system capable of reading in a string and turning delimited fields into strings, floats, and ints can consume <a class="el" href="classSKINI.html">SKINI</a> for control. More importantly, humans can actually read, and even write if they want, <a class="el" href="classSKINI.html">SKINI</a> files and streams. Use an editor and search/replace or macros to change a channel or control number. Load a <a class="el" href="classSKINI.html">SKINI</a> score into a spread sheet to apply transformations to time, control parameters, MIDI velocities, etc. Put a monkey on a special typewriter and get your next great work. Life's too short to debug bit/nybble packed variable length mumble messages. Disk space gets cheaper, available bandwidth increases, music takes up so little space and bandwidth compared to video and grapics. Live a little.</li></ul>
<p>
<ul>
<li>Floating point numbers are used wherever possible. Note Numbers, Velocities, Controller Values, and Delta and Absolute Times are all represented and scanned as ASCII double-precision floats. MIDI byte values are preserved, so that incoming MIDI bytes from an interface can be put directly into <a class="el" href="classSKINI.html">SKINI</a> messages. 60.0 or 60 is middle C, 127.0 or 127 is maximum velocity etc. But, unlike MIDI, 60.5 can cause a 50 cent sharp middle C to be played. As with MIDI byte values like velocity, use of the integer and SKINI-added fractional parts is up to the implementor of the algorithm being controlled by <a class="el" href="classSKINI.html">SKINI</a> messages. But the extra precision is there to be used or ignored.</li></ul>
<h2><a class="anchor" name="why">
Why SKINI?</a></h2>
<a class="el" href="classSKINI.html">SKINI</a> was designed to be extensable and hackable for a number of applications: imbedded synthesis in a game or VR simulation, scoring and mixing tasks, real-time and non-real time applications which could benefit from controllable sound synthesis, JAVA controlled synthesis, or eventually maybe JAVA synthesis, etc. <a class="el" href="classSKINI.html">SKINI</a> is not intended to be "the mother of scorefiles," but since the entire system is based on text representations of names, floats, and ints, converters from one scorefile language to <a class="el" href="classSKINI.html">SKINI</a>, or back, should be easily created.<p>
I am basically a bottom-up designer with an awareness of top-down design ideas, so <a class="el" href="classSKINI.html">SKINI</a> above all reflects the needs of my particular research and creative projects as they have arisen and developed. <a class="el" href="classSKINI.html">SKINI</a> 1.1 represents a profound advance beyond versions 0.8 and 0.9 (the first versions), future SKINI's might reflect some changes. Compatibility with prior scorefiles will be attempted, but there aren't that many scorefiles out there yet.<h2><a class="anchor" name="messages">
SKINI Messages</a></h2>
A basic <a class="el" href="classSKINI.html">SKINI</a> message is a line of text. There are only three required fields, the message type (an ASCII name), the time (either delta or absolute), and the channel number. Don't freak out and think that this is MIDI channel 0-15 (which is supported), because the channel number is scanned as a long int. Channels could be socket numbers, machine IDs, serial numbers, or even unique tags for each event in a synthesis. Other fields might be used, as specified in the SKINI.tbl file. This is described in more detail later.<p>
Fields in a <a class="el" href="classSKINI.html">SKINI</a> line are delimited by spaces, commas, or tabs. The <a class="el" href="classSKINI.html">SKINI</a> parser only operates on a line at a time, so a newline means the message is over. Multiple messages are NOT allowed directly on a single line (by use of the ; for example in C). This could be supported, but it isn't in version 1.1.<p>
Message types include standard MIDI types like NoteOn, NoteOff, ControlChange, etc. MIDI extension message types (messages which look better than MIDI but actually get turned into MIDI-like messages) include LipTension, StringDamping, etc. Non-MIDI message types include SetPath (sets a path for file use later), and OpenReadFile (for streaming, mixing, and applying effects to soundfiles along with synthesis, for example). Other non-MIDI message types include Trilling, HammerOn, etc. (these translate to gestures, behaviors, and contexts for use by intellegent players and instruments using <a class="el" href="classSKINI.html">SKINI</a>). Where possible I will still use these as MIDI extension messages, so foot switches, etc. can be used to control them in real time.<p>
All fields other than type, time, and channel are optional, and the types and useage of the additional fields is defined in the file SKINI.tbl.<p>
The other important file used by <a class="el" href="classSKINI.html">SKINI</a> is SKINI.msg, which is a set of #defines to make C code more readable, and to allow reasonably quick re-mapping of control numbers, etc.. All of these defined symbols are assigned integer values. For Java, the #defines could be replaced by declaration and assignment statements, preserving the look and behavior of the rest of the code.<h2><a class="anchor" name="cfiles">
C Files Used To Implement SKINI</a></h2>
SKINI.cpp is an object which can either open a <a class="el" href="classSKINI.html">SKINI</a> file, and successively read and parse lines of text as <a class="el" href="classSKINI.html">SKINI</a> strings, or accept strings from another object and parse them. The latter functionality would be used by a socket, pipe, or other connection receiving <a class="el" href="classSKINI.html">SKINI</a> messages a line at a time, usually in real time, but not restricted to real time.<p>
SKINI.msg should be included by anything wanting to use the SKINI.cpp object. This is not mandatory, but use of the __SK_blah_ symbols which are defined in the .msg file will help to ensure clarity and consistency when messages are added and changed.<p>
SKINI.tbl is used only by the <a class="el" href="classSKINI.html">SKINI</a> parser object (SKINI.cpp). In the file SKINI.tbl, an array of structures is declared and assigned values which instruct the parser as to what the message types are, and what the fields mean for those message types. This table is compiled and linked into applications using <a class="el" href="classSKINI.html">SKINI</a>, but could be dynamically loaded and changed in a future version of <a class="el" href="classSKINI.html">SKINI</a>.<h2><a class="anchor" name="parser">
SKINI Messages and the SKINI Parser:</a></h2>
The parser isn't all that smart, but neither am I. Here are the basic rules governing a valid <a class="el" href="classSKINI.html">SKINI</a> message:<p>
<ul>
<li>If the first (non-delimiter ... see below) character in a <a class="el" href="classSKINI.html">SKINI</a> string is '/' that line is treated as a comment and echoed to stdout.</li></ul>
<p>
<ul>
<li>If there are no characters on a line, that line is treated as blank and echoed to stdout. Tabs and spaces are treated as non-characters.</li></ul>
<p>
<ul>
<li>Spaces, commas, and tabs delimit the fields in a <a class="el" href="classSKINI.html">SKINI</a> message line. (We might allow for multiple messages per line later using the semicolon, but probably not. A series of lines with deltaTimes of 0.0 denotes simultaneous events. For read-ability, multiple messages per line doesn't help much, so it's unlikely to be supported later).</li></ul>
<p>
<ul>
<li>The first field must be a <a class="el" href="classSKINI.html">SKINI</a> message name (like NoteOn). These might become case-insensitive in future versions, so don't plan on exciting clever overloading of names (like noTeOn being different from NoTeON). There can be a number of leading spaces or tabs, but don't exceed 32 or so.</li></ul>
<p>
<ul>
<li>The second field must be a time specification in seconds. A time field can be either delta-time (most common and the only one supported in version 0.8), or absolute time. Absolute time messages have an '=' appended to the beginning of the floating point number with no space. So 0.10000 means delta time of 100 ms, while =0.10000 means absolute time of 100 ms. Absolute time messages make most sense in score files, but could also be used for (loose) synchronization in a real-time context. Real-time messages should be time-ordered AND time-correct. That is, if you've sent 100 total delta-time messages of 1.0 seconds, and then send an absolute time message of =90.0 seconds, or if you send two absolute time messages of =100.0 and =90.0 in that order, things will get really fouled up. The <a class="el" href="classSKINI.html">SKINI</a> parser doesn't know about time, however. The <a class="el" href="classWvOut.html">WvOut</a> device is the master time keeper in the Synthesis Toolkit, so it should be queried to see if absolute time messages are making sense. There's an example of how to do that later in this document. Absolute times are returned by the parser as negative numbers (since negative deltaTimes are not allowed).</li></ul>
<p>
<ul>
<li>The third field must be an integer channel number. Don't go crazy and think that this is just MIDI channel 0-15 (which is supported). The channel number is scanned as a long int. Channels 0-15 are in general to be treated as MIDI channels. After that it's wide open. Channels could be socket numbers, machine IDs, serial numbers, or even unique tags for each event in a synthesis. A -1 channel can be used as don't care, omni, or other functions depending on your needs and taste.</li></ul>
<p>
<ul>
<li>All remaining fields are specified in the SKINI.tbl file. In general, there are maximum two more fields, which are either SK_INT (long), SK_DBL (double float), or SK_STR (string). The latter is the mechanism by which more arguments can be specified on the line, but the object using <a class="el" href="classSKINI.html">SKINI</a> must take that string apart (retrived by using getRemainderString()) and scan it. Any excess fields are stashed in remainderString.</li></ul>
<h2><a class="anchor" name="file">
A Short SKINI File:</a></h2>
<div class="fragment"><pre>        <span class="comment">/*  Howdy!!! Welcome to SKINI, by P. Cook 1999</span>
<span class="comment"></span>
<span class="comment">        NoteOn          0.000082 2 55 82</span>
<span class="comment">        NoteOff         1.000000 2 55 0</span>
<span class="comment">        NoteOn          0.000082 2 69 82</span>
<span class="comment">        StringDetune    0.100000 2    10</span>
<span class="comment">        StringDetune    0.100000 2    30</span>
<span class="comment">        StringDetune    0.100000 2    50</span>
<span class="comment">        NoteOn          0.000000 2 69 82</span>
<span class="comment">        StringDetune    0.100000 2    40</span>
<span class="comment">        StringDetune    0.100000 2    22</span>
<span class="comment">        StringDetune    0.100000 2    12</span>
<span class="comment">        //</span>
<span class="comment">        StringDamping   0.000100 2     0.0</span>
<span class="comment">        NoteOn          0.000082 2 55 82</span>
<span class="comment">        NoteOn          0.200000 2 62 82</span>
<span class="comment">        NoteOn          0.100000 2 71 82</span>
<span class="comment">        NoteOn          0.200000 2 79 82</span>
<span class="comment">        NoteOff         1.000000 2 55 82</span>
<span class="comment">        NoteOff         0.000000 2 62 82</span>
<span class="comment">        NoteOff         0.000000 2 71 82</span>
<span class="comment">        NoteOff         0.000000 2 79 82</span>
<span class="comment">        StringDamping  =4.000000 2       0.0</span>
<span class="comment">        NoteOn          0.000082 2 55 82</span>
<span class="comment">        NoteOn          0.200000 2 62 82</span>
<span class="comment">        NoteOn          0.100000 2 71 82</span>
<span class="comment">        NoteOn          0.200000 2 79 82</span>
<span class="comment">        NoteOff         1.000000 2 55 82</span>
<span class="comment">        NoteOff         0.000000 2 62 82</span>
<span class="comment">        NoteOff         0.000000 2 71 82</span>
<span class="comment">        NoteOff         0.000000 2 79 82</span>
</pre></div><h2><a class="anchor" name="table">
The SKINI.tbl File and Message Parsing:</a></h2>
The SKINI.tbl file contains an array of structures which are accessed by the parser object SKINI.cpp. The struct is:<p>
<div class="fragment"><pre><span class="keyword">struct </span>SKINISpec {
   <span class="keywordtype">char</span> messageString[32];
   <span class="keywordtype">long</span>  type;
   <span class="keywordtype">long</span> data2;
   <span class="keywordtype">long</span> data3;
};
</pre></div><p>
so an assignment of one of these structs looks like:<p>
<div class="fragment"><pre>        MessageStr$      ,type, data2, data3,
</pre></div><p>
<code>type</code> is the message type sent back from the <a class="el" href="classSKINI.html">SKINI</a> line parser.<p>
<code>data&lt;n&gt;</code> is either:<p>
<ul>
<li>NOPE : field not used, specifically, there aren't going to be any more fields on this line. So if there is is NOPE in data2, data3 won't even be checked.</li></ul>
<p>
<ul>
<li>SK_INT : byte (actually scanned as 32 bit signed long int). If it's a MIDI data field which is required to be an integer, like a controller number, it's 0-127. Otherwise, get creative with SK_INTs.</li></ul>
<p>
<ul>
<li>SK_DBL : double precision floating point. <a class="el" href="classSKINI.html">SKINI</a> uses these in the MIDI context for note numbers with micro tuning, velocities, controller values, etc.</li></ul>
<p>
<ul>
<li>SK_STR : only valid in final field. This allows (nearly) arbitrary message types to be supported by simply scanning the string to EndOfLine and then passing it to a more intellegent handler. For example, MIDI SYSEX (system exclusive) messages of up to 256 bytes can be read as space-delimited integers into the 1K SK_STR buffer. Longer bulk dumps, soundfiles, etc. should be handled as a new message type pointing to a FileName, <a class="el" href="classSocket.html">Socket</a>, or something else stored in the SK_STR field, or as a new type of multi-line message.</li></ul>
<p>
Here's a couple of lines from the SKINI.tbl file<p>
<div class="fragment"><pre> {<span class="stringliteral">"NoteOff"</span>          ,        __SK_NoteOff_,               SK_DBL,  SK_DBL},
 {<span class="stringliteral">"NoteOn"</span>           ,         __SK_NoteOn_,               SK_DBL,  SK_DBL},

 {<span class="stringliteral">"ControlChange"</span>    ,  __SK_ControlChange_,               SK_INT,  SK_DBL},
 {<span class="stringliteral">"Volume"</span>           ,  __SK_ControlChange_, __SK_Volume_        ,  SK_DBL},

 {<span class="stringliteral">"StringDamping"</span>    ,   __SK_ControlChange_, __SK_StringDamping_,  SK_DBL},
 {<span class="stringliteral">"StringDetune"</span>     ,    __SK_ControlChange_, __SK_StringDetune_,  SK_DBL},
</pre></div><p>
The first three are basic MIDI messages. The first two would cause the parser, after recognizing a match of the string "NoteOff" or "NoteOn", to set the message type to 128 or 144 (__SK_NoteOff_ and __SK_NoteOn_ are #defined in the file SKINI.msg to be the MIDI byte value, without channel, of the actual MIDI messages for NoteOn and NoteOff). The parser would then set the time or delta time (this is always done and is therefore not described in the <a class="el" href="classSKINI.html">SKINI</a> Message Struct). The next two fields would be scanned as double-precision floats and assigned to the byteTwo and byteThree variables of the <a class="el" href="classSKINI.html">SKINI</a> parser. The remainder of the line is stashed in the remainderString variable.<p>
The ControlChange spec is basically the same as NoteOn and NoteOff, but the second data byte is set to an integer (for checking later as to what MIDI control is being changed).<p>
The Volume spec is a MIDI Extension message, which behaves like a ControlChange message with the controller number set explicitly to the value for MIDI Volume (7). Thus the following two lines would accomplish the same changing of MIDI volume on channel 2:<p>
<div class="fragment"><pre>    ControlChange  0.000000 2 7 64.1
    Volume         0.000000 2   64.1
</pre></div><p>
I like the 2nd line better, thus my motivation for <a class="el" href="classSKINI.html">SKINI</a> in the first place.<p>
The StringDamping and StringDetune messages behave the same as the Volume message, but use Control Numbers which aren't specifically nailed-down in MIDI. Note that these Control Numbers are carried around as long ints, so we're not limited to 0-127. If, however, you want to use a MIDI controller to play an instrument, using controller numbers in the 0-127 range might make sense.<h2><a class="anchor" name="using">
Using SKINI:</a></h2>
Here's a simple example of code which uses the <a class="el" href="classSKINI.html">SKINI</a> object to read a <a class="el" href="classSKINI.html">SKINI</a> file and control a single instrument.<p>
<div class="fragment"><pre>        instrument = <span class="keyword">new</span> <a class="code" href="classMandolin.html">Mandolin</a>(50.0);
        score = <span class="keyword">new</span> <a class="code" href="classSKINI.html">SKINI</a>(argv[1]);
        <span class="keywordflow">while</span>(score-&gt;getType() &gt; 0) {
            tempDouble = score-&gt;getDelta();
            <span class="keywordflow">if</span> (tempDouble &lt; 0)     {
                tempDouble = - tempDouble;
                tempDouble = tempDouble - output.<a class="code" href="classRtWvOut.html#a5">getTime</a>();
                <span class="keywordflow">if</span> (tempDouble &lt; 0) {
                   printf(<span class="stringliteral">"Bad News Here!!!  Backward Absolute Time Required.\n"</span>);
                   tempDouble = 0.0;
                }
            }
            tempLong = (<span class="keywordtype">long</span>) (tempDouble * <a class="code" href="classStk.html#e0">Stk::sampleRate</a>());
            <span class="keywordflow">for</span> (i=0;i&lt;tempLong;i++)   {
                output.<a class="code" href="classRtWvOut.html#a6">tick</a>(instrument-&gt;<a class="code" href="classInstrmnt.html#a8">tick</a>());
            }
            tempDouble3 = score-&gt;getByteThree();
            <span class="keywordflow">if</span> (score-&gt;getType()== __SK_NoteOn_ )        {
                tempDouble3 *= NORM_MIDI;
                <span class="keywordflow">if</span> (score-&gt;getByteThree() == 0)  {
                    tempDouble3 = 0.5;
                    instrument-&gt;<a class="code" href="classInstrmnt.html#a3">noteOff</a>(tempDouble3);
                }
                <span class="keywordflow">else</span> {
                    tempLong = (<span class="keywordtype">int</span>) score-&gt;getByteTwo();
                    tempDouble2 = Midi2Pitch[tempLong];
                    instrument-&gt;<a class="code" href="classInstrmnt.html#a2">noteOn</a>(tempDouble2,tempDouble3);
                }
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (score-&gt;getType() == __SK_NoteOff_) {
                tempDouble3 *= NORM_MIDI;
                instrument-&gt;<a class="code" href="classInstrmnt.html#a3">noteOff</a>(tempDouble3);
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (score-&gt;getType() == __SK_ControlChange_)        {
                tempLong = score-&gt;getByteTwoInt();
                instrument-&gt;<a class="code" href="classInstrmnt.html#a10">controlChange</a>(tempLong,temp3.0);
            }
            score-&gt;nextMessage();
        }
</pre></div><p>
When the score (<a class="el" href="classSKINI.html">SKINI</a> object) object is created from the filename in argv[1], the first valid command line is read from the file and parsed.<p>
The score-&gt;getType() retrieves the messageType. If this is -1, there are no more valid messages in the file and the synthesis loop terminates. Otherwise, the message type is returned.<p>
getDelta() retrieves the deltaTime until the current message should occur. If this is greater than 0, synthesis occurs until the deltaTime has elapsed. If deltaTime is less than zero, the time is interpreted as absolute time and the output device is queried as to what time it is now. That is used to form a deltaTime, and if it's positive we synthesize. If it's negative, we print an error and pretend this never happened and we hang around hoping to eventually catch up.<p>
The rest of the code sorts out message types NoteOn, NoteOff (including NoteOn with velocity 0), and ControlChange. The code implicitly takes into account the integer type of the control number, but all other data is treated as double float.<p>
The last line reads and parses the next message in the file. <HR>

<table>
  <tr><td><A HREF="http://www-ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995-2004 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>

</BODY>
</HTML>
